### [452. 用最少数量的箭引爆气球](https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/)

@2020-11-24    没有解题思路，参考了官方思路和答案

		【题目解析】
			（1）要使每只箭射中尽可能多的气球 ==> 误区：容易盯着气球不放
			（2）每个气球的位置是固定的
			 解题的关键是：找出放箭的位置，使每只箭引爆数量最大
		
		【解题思路】
		     每只箭要引爆最大数量，那么必然满足：
		  			a. 箭是贴着某个气球的边缘射出的，且必然是右边缘（因右边缘才能与其他气球左边缘交叉时，可射中两个）
		  			b. 从某个右边缘射出一箭，若要最大化引爆量，那么必然满足：
		  					i. 右边缘位置（即放箭位置） <= 所有被射中气球的右边缘位置
		  				 ii. 所有被射中气球的左边缘位置 <= 右边缘位置（即放箭位置）
		          iii. 所有未被射中气球的左边缘位置 > 右边缘位置（即放箭位置）
		           iv. 下一支箭的位置 = 所有未被射中气球中最小的右边缘位置
		     
		     经过上述分析，题目涉及两类算法：
		     		* 排序算法
		     		* 贪心算法

```java
class Solution {
    public int findMinArrowShots(int[][] points) {
        if (points.length == 0){
            return 0;
        }
        //对气球右端按照有小到大排序
        //每个point由左端点point[0]和右端点point[1]构成
        Arrays.sort(points, new Comparator<int[]>() {
            @Override
            public int compare(int[] point1, int[] point2) {
                if(point1[1]>point2[1]){
                    return 1 ;
                }else if(point1[1]<point2[1]){
                    return -1 ;
                }else {
                    return 0;
                }
            }
        });

        int pos = points[0][1]; //第一只箭必然是从第一个气球的右端点放出
        int ans = 1; //必然至少一支箭

        for (int[] balloon: points) {
            /**
             * 1. 排序后的气球，箭必然从每个气球的右端点放出
             * 2. 若某个气球的左端点 > 放出箭的气球的右端点，意味着：
             *    （1）两个气球没有交集，因有序所以后面气球也如此
             *    （2）当前放出的箭达到了能射中的最大值，需要再放一只新的箭
             *    （3）新箭放出的位置 = 未被上支箭射中的第一个气球的右端点
             */
            if(balloon[0]>pos){
                pos = balloon[1];
                ans = ans + 1;
            }
        }
        return ans;
    }
}
```

